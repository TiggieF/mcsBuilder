<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>mcsBuilder — Stage 00 Scaffold</title>
  <style>
    :root {
      --bg: #0f1321;
      --panel-bg: #1d1e2b;
      --panel-border: #393b52;
      --text: #f5f5f8;
      --accent: #6bd3ff;
      --hud-bg: rgba(12, 14, 24, 0.92);
      --bubble-bg: rgba(20, 20, 30, 0.95);
      font-size: 16px;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Press Start 2P", "VT323", "Courier New", monospace;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    body.high-contrast {
      --bg: #050505;
      --panel-bg: #000000;
      --panel-border: #ffffff;
      --text: #ffffff;
      --hud-bg: rgba(0, 0, 0, 0.92);
      --bubble-bg: rgba(0, 0, 0, 0.95);
    }

    h1, h2, h3 {
      font-size: 1rem;
      letter-spacing: 0.05em;
      margin: 0 0 0.75rem;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.25rem;
      background: var(--hud-bg);
      border-bottom: 2px solid var(--panel-border);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
    }

    .hud span.value {
      color: var(--accent);
      margin-left: 0.5rem;
    }

    .main-wrapper {
      display: flex;
      flex: 1;
      gap: 1.5rem;
      padding: 1.5rem;
      box-sizing: border-box;
    }

    canvas {
      border: 3px solid var(--panel-border);
      image-rendering: pixelated;
      background: #10181f;
      flex-shrink: 0;
    }

    .panel {
      width: 260px;
      background: var(--panel-bg);
      border: 3px solid var(--panel-border);
      padding: 1.25rem;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      height: fit-content;
    }

    .panel button {
      width: 100%;
      padding: 0.75rem;
      background: transparent;
      color: var(--text);
      border: 2px solid var(--panel-border);
      cursor: pointer;
      font-family: inherit;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      transition: background 0.2s ease;
    }

    .panel button:hover,
    .panel button:focus {
      background: rgba(255, 255, 255, 0.08);
      outline: none;
    }

    .panel .worker-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .panel .worker-group button {
      text-align: left;
      display: flex;
      justify-content: space-between;
    }

    #textBubble {
      position: absolute;
      transform: translate(-50%, -110%);
      background: var(--bubble-bg);
      border: 2px solid var(--panel-border);
      padding: 0.6rem 0.9rem;
      border-radius: 6px;
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      max-width: 280px;
      text-align: center;
      display: none;
      pointer-events: none;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 20;
    }

    .panel .status {
      font-size: 0.65rem;
      line-height: 1.4;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div>Wood Stock<span class="value" id="hud-wood">1/5</span></div>
    <div>Current Floor<span class="value" id="hud-floor">1</span></div>
    <div>Progress<span class="value" id="hud-progress">12%</span></div>
    <div>Total Time<span class="value" id="hud-time">00:00</span></div>
  </div>
  <div class="main-wrapper">
    <canvas id="gameCanvas" width="1020" height="600" aria-label="mcsBuilder stage 00 playfield"></canvas>
    <aside class="panel" aria-label="control panel">
      <h2>Control Panel</h2>
      <button id="pauseBtn" type="button">Pause</button>
      <button id="speedBtn" type="button">Speed: 1×</button>
      <button id="contrastBtn" type="button">Contrast</button>
      <section class="worker-group" aria-label="worker commands">
        <h3>Workers</h3>
        <button class="worker-btn" data-worker="builder" type="button">Builder<span>idle</span></button>
        <button class="worker-btn" data-worker="delivery" type="button">Delivery<span>idle</span></button>
      </section>
      <p class="status" id="panelStatus">Awaiting input…</p>
    </aside>
  </div>
  <div id="textBubble" role="status" aria-live="polite"></div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const grid = { cols: 34, rows: 20, cell: 30 };
    const frameDuration = 1000 / 30;

    canvas.width = grid.cols * grid.cell;
    canvas.height = grid.rows * grid.cell;

    const player = {
      x: Math.floor(grid.cols / 2) * grid.cell - 15,
      y: (grid.rows - 3) * grid.cell,
      width: 26,
      height: 26,
      speed: 150,
      color: '#f9f871'
    };

    const textures = {
      grass: createGrassPattern('#264620', '#2f5a28', '#1f3c17'),
      mcs: createStripedPattern('#3c496f', '#4f6290'),
      building: createBrickPattern('#7b5432', '#5b3b20'),
      cafe: createBrickPattern('#234338', '#1a3127'),
      dorm: createStripedPattern('#4a3562', '#6b4a87')
    };

    const zones = generateZones(player);

    const workers = [
      { name: 'Builder', x: (grid.cols / 2 - 1.5) * grid.cell, y: (grid.rows / 2 + 1) * grid.cell, color: '#ffd166', state: 'idle' },
      { name: 'Delivery', x: (grid.cols / 2 + 1.5) * grid.cell, y: (grid.rows / 2 + 1.5) * grid.cell, color: '#4cc9f0', state: 'idle' }
    ];

    const keys = {};
    let isPaused = false;
    let speedMultiplier = 1;
    let progress = 0.12;
    let totalTime = 0;
    const woodStock = { current: 1, capacity: 5 };
    let bubbleTimeout = null;

    const statusEl = document.getElementById('panelStatus');
    const hudWood = document.getElementById('hud-wood');
    const hudFloor = document.getElementById('hud-floor');
    const hudProgress = document.getElementById('hud-progress');
    const hudTime = document.getElementById('hud-time');
    const bubble = document.getElementById('textBubble');
    bubble.style.display = 'none';

    function rectsOverlap(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function expandedRect(rect, padding) {
      return {
        x: rect.x - padding,
        y: rect.y - padding,
        width: rect.width + padding * 2,
        height: rect.height + padding * 2
      };
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
      const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
      return `${mins}:${secs}`;
    }

    function updateHUD() {
      hudWood.textContent = `${woodStock.current}/${woodStock.capacity}`;
      hudFloor.textContent = '1';
      hudProgress.textContent = `${Math.round(progress * 100)}%`;
      hudTime.textContent = formatTime(totalTime);
    }

    function createGrassPattern(primary, secondary, accent) {
      const tile = document.createElement('canvas');
      tile.width = 32;
      tile.height = 32;
      const tctx = tile.getContext('2d');
      tctx.fillStyle = primary;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = secondary;
      for (let i = 0; i < 45; i++) {
        const x = Math.floor(Math.random() * tile.width);
        const y = Math.floor(Math.random() * tile.height);
        tctx.fillRect(x, y, 1, 1);
      }
      tctx.fillStyle = accent;
      for (let i = 0; i < 18; i++) {
        const x = Math.floor(Math.random() * tile.width);
        const y = Math.floor(Math.random() * tile.height);
        tctx.fillRect(x, y, 1, 1);
      }
      return ctx.createPattern(tile, 'repeat');
    }

    function createStripedPattern(primary, secondary) {
      const tile = document.createElement('canvas');
      tile.width = 16;
      tile.height = 16;
      const tctx = tile.getContext('2d');
      tctx.fillStyle = primary;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = secondary;
      for (let y = 0; y < tile.height; y += 2) {
        tctx.fillRect(0, y, tile.width, 1);
      }
      return ctx.createPattern(tile, 'repeat');
    }

    function createBrickPattern(base, mortar) {
      const tile = document.createElement('canvas');
      tile.width = 24;
      tile.height = 24;
      const tctx = tile.getContext('2d');
      tctx.fillStyle = mortar;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = base;
      for (let row = 0; row < tile.height; row += 8) {
        for (let col = (row / 8) % 2 === 0 ? 0 : 12; col < tile.width; col += 24) {
          tctx.fillRect(col, row, 12, 6);
        }
        for (let col = (row / 8) % 2 === 0 ? 12 : 0; col < tile.width; col += 24) {
          tctx.fillRect(col, row + 3, 12, 6);
        }
      }
      return ctx.createPattern(tile, 'repeat');
    }

    function generateZones(playerRef) {
      const placed = [];
      const zones = [];

      const mcs = {
        name: 'MCS Construction',
        description: 'Future site of the Computer Science building.',
        x: Math.floor(grid.cols / 2 - 2.5) * grid.cell,
        y: Math.floor(grid.rows / 2 - 2.5) * grid.cell,
        width: 5 * grid.cell,
        height: 5 * grid.cell,
        color: textures.mcs,
        solid: true
      };
      zones.push(mcs);
      placed.push(mcs);

      const configs = [
        {
          name: 'Wood House',
          description: 'Stockpile for framing lumber.',
          tilesWide: 2,
          tilesHigh: 2,
          color: textures.building
        },
        {
          name: 'Starbucks',
          description: 'Quick caffeine stop for the crew.',
          tilesWide: 2,
          tilesHigh: 2,
          color: textures.cafe
        },
        {
          name: 'Dorm Beds',
          description: 'Where exhausted workers rest up.',
          tilesWide: 2,
          tilesHigh: 2,
          color: textures.dorm
        }
      ];

      configs.forEach(config => {
        const zone = placeRandomZone(config, placed, playerRef);
        zones.push(zone);
        placed.push(zone);
      });

      return zones;
    }

    function placeRandomZone(config, placed, playerRef) {
      const width = config.tilesWide * grid.cell;
      const height = config.tilesHigh * grid.cell;
      const maxCol = grid.cols - config.tilesWide;
      const maxRow = grid.rows - config.tilesHigh;
      let attempts = 0;
      while (attempts < 400) {
        const col = Math.floor(Math.random() * (maxCol + 1));
        const row = Math.floor(Math.random() * (maxRow + 1));
        const zone = {
          name: config.name,
          description: config.description,
          x: col * grid.cell,
          y: row * grid.cell,
          width,
          height,
          color: config.color,
          solid: true
        };

        const padded = placed.some(existing => rectsOverlap(zone, expandedRect(existing, grid.cell * 0.75)));
        const blocksPlayer = playerRef && rectsOverlap(zone, expandedRect(playerRef, grid.cell));

        if (!padded && !blocksPlayer) {
          return zone;
        }
        attempts += 1;
      }

      return {
        name: config.name,
        description: config.description,
        x: 0,
        y: 0,
        width,
        height,
        color: config.color,
        solid: true
      };
    }

    function handleMovement(dt) {
      let vx = 0;
      let vy = 0;
      if (keys['KeyW']) vy -= 1;
      if (keys['KeyS']) vy += 1;
      if (keys['KeyA']) vx -= 1;
      if (keys['KeyD']) vx += 1;

      if (vx !== 0 && vy !== 0) {
        const inv = Math.SQRT1_2;
        vx *= inv;
        vy *= inv;
      }

      const distance = player.speed * dt * speedMultiplier;
      const solids = zones.filter(z => z.solid);

      if (vx !== 0) {
        const nextRect = {
          x: player.x + vx * distance,
          y: player.y,
          width: player.width,
          height: player.height
        };
        if (!solids.some(s => rectsOverlap(nextRect, s))) {
          player.x = nextRect.x;
        }
      }

      if (vy !== 0) {
        const nextRect = {
          x: player.x,
          y: player.y + vy * distance,
          width: player.width,
          height: player.height
        };
        if (!solids.some(s => rectsOverlap(nextRect, s))) {
          player.y = nextRect.y;
        }
      }

      player.x = Math.max(2, Math.min(player.x, canvas.width - player.width - 2));
      player.y = Math.max(2, Math.min(player.y, canvas.height - player.height - 2));
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      ctx.lineWidth = 1;
      for (let col = 1; col < grid.cols; col++) {
        const x = col * grid.cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let row = 1; row < grid.rows; row++) {
        const y = row * grid.cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function drawZones() {
      zones.forEach(zone => {
        if (zone.color instanceof CanvasPattern) {
          ctx.fillStyle = zone.color;
        } else {
          ctx.fillStyle = zone.color;
        }
        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
        ctx.fillRect(zone.x, zone.y, zone.width, 18);
        ctx.fillStyle = '#f7f7fb';
        ctx.font = '12px "Press Start 2P", "VT323", monospace';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'center';
        ctx.fillText(zone.name, zone.x + zone.width / 2, zone.y + 2);
      });
      ctx.textAlign = 'left';
    }

    function drawWorkers() {
      ctx.font = '12px "Press Start 2P", "VT323", monospace';
      ctx.textBaseline = 'bottom';
      workers.forEach(worker => {
        ctx.fillStyle = '#00000088';
        ctx.fillRect(worker.x - 4, worker.y + 20, 28, 8);
        ctx.fillStyle = worker.color;
        ctx.fillRect(worker.x, worker.y, 20, 20);
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(worker.x + 4, worker.y + 4, 4, 4);
        ctx.fillRect(worker.x + 12, worker.y + 4, 4, 4);
        ctx.fillStyle = '#f08080';
        ctx.fillRect(worker.x + 6, worker.y + 13, 8, 5);

        ctx.fillStyle = '#000000aa';
        ctx.fillRect(worker.x - 20, worker.y - 24, 60, 18);
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.fillText(worker.name, worker.x + 10, worker.y - 6);
        ctx.fillStyle = '#a6f1ff';
        ctx.fillText(worker.state, worker.x + 10, worker.y - 18);
      });
      ctx.textAlign = 'left';
    }

    function drawPlayer() {
      ctx.fillStyle = '#00000088';
      ctx.fillRect(player.x - 4, player.y + player.height, player.width + 8, 8);
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(player.x + 4, player.y + 2, player.width - 8, player.height - 6);
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height - 6);
      ctx.fillStyle = '#2b2e4a';
      ctx.fillRect(player.x + 6, player.y + 4, 4, 4);
      ctx.fillRect(player.x + player.width - 10, player.y + 4, 4, 4);
      ctx.fillStyle = '#f25f5c';
      ctx.fillRect(player.x + 8, player.y + player.height - 12, 10, 8);
    }

    function drawScene() {
      if (textures.grass) {
        ctx.fillStyle = textures.grass;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#0e1320';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      drawGrid();
      drawZones();
      drawWorkers();
      drawPlayer();
    }

    function update(dt) {
      if (!isPaused) {
        handleMovement(dt);
        totalTime += dt * speedMultiplier;
        progress = Math.min(1, progress + dt * 0.005 * speedMultiplier);
      }
      updateHUD();
    }

    function getContextZone() {
      const playerRect = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };
      return zones.find(zone => rectsOverlap(playerRect, expandedRect(zone, 10)));
    }

    function showBubble(message) {
      bubble.textContent = message;
      bubble.style.display = 'block';
      positionBubble();
      if (bubbleTimeout) {
        clearTimeout(bubbleTimeout);
      }
      bubbleTimeout = setTimeout(() => {
        bubble.style.display = 'none';
      }, 2200);
    }

    function interact() {
      const zone = getContextZone();
      if (zone) {
        showBubble(`${zone.name}: ${zone.description}`);
      } else {
        showBubble('You wave into the quiet night. Nothing happens.');
      }
    }

    function togglePause() {
      isPaused = !isPaused;
      document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
      statusEl.textContent = isPaused ? 'Simulation paused.' : 'Simulation running.';
    }

    function cycleSpeed() {
      if (speedMultiplier === 1) {
        speedMultiplier = 2;
      } else if (speedMultiplier === 2) {
        speedMultiplier = 0.5;
      } else {
        speedMultiplier = 1;
      }
      document.getElementById('speedBtn').textContent = `Speed: ${speedMultiplier}×`;
      statusEl.textContent = `Speed set to ${speedMultiplier.toFixed(1)}×.`;
    }

    function toggleContrast() {
      document.body.classList.toggle('high-contrast');
      statusEl.textContent = document.body.classList.contains('high-contrast')
        ? 'High contrast enabled.'
        : 'High contrast disabled.';
    }

    function handleWorkerClick(workerName) {
      statusEl.textContent = `${workerName} remains idle (placeholder).`;
      showBubble(`${workerName} acknowledges the order but keeps idling.`);
    }

    function positionBubble() {
      if (bubble.style.display === 'none') {
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const pageX = rect.left + window.scrollX + player.x + player.width / 2;
      const pageY = rect.top + window.scrollY + player.y - 6;
      bubble.style.left = `${pageX}px`;
      bubble.style.top = `${pageY}px`;
    }

    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault();
        interact();
        return;
      }
      keys[event.code] = true;
    });

    document.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });

    window.addEventListener('resize', positionBubble);
    window.addEventListener('scroll', positionBubble);

    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('speedBtn').addEventListener('click', cycleSpeed);
    document.getElementById('contrastBtn').addEventListener('click', toggleContrast);

    document.querySelectorAll('.worker-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const workerName = btn.dataset.worker === 'builder' ? 'Builder' : 'Delivery';
        handleWorkerClick(workerName);
      });
    });

    updateHUD();
    drawScene();
    setInterval(() => {
      update(1 / 30);
      drawScene();
      positionBubble();
    }, frameDuration);
  </script>
</body>
</html>
