<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>mcsBuilder — Stage 04 UI & FSM Prototype</title>
  <style>
    :root {
      --bg: #0f1321;
      --panel-bg: #1d1e2b;
      --panel-border: #3a3d55;
      --text: #f5f5f8;
      --accent: #6bd3ff;
      --hud-bg: rgba(12, 14, 24, 0.92);
      --bubble-bg: rgba(20, 20, 30, 0.95);
      font-size: 16px;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Press Start 2P", "VT323", "Courier New", monospace;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    body.high-contrast {
      --bg: #050505;
      --panel-bg: #000000;
      --panel-border: #ffffff;
      --text: #ffffff;
      --hud-bg: rgba(0, 0, 0, 0.92);
      --bubble-bg: rgba(0, 0, 0, 0.95);
    }

    h1, h2, h3 {
      font-size: 1rem;
      letter-spacing: 0.05em;
      margin: 0 0 0.75rem;
    }

    .hud {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 1rem;
      padding: 0.75rem 1.25rem;
      background: var(--hud-bg);
      border-bottom: 2px solid var(--panel-border);
      text-transform: uppercase;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      box-sizing: border-box;
    }

    .hud-item {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .hud-item .label {
      opacity: 0.75;
    }

    .hud-item .value {
      color: var(--accent);
      font-size: 0.75rem;
    }

    .hud-item.bar-item {
      gap: 0.4rem;
    }

    .bar {
      position: relative;
      height: 22px;
      border: 2px solid var(--panel-border);
      background: rgba(10, 14, 24, 0.7);
      overflow: hidden;
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.08);
    }

    .bar .fill {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, #67f3a2, #2db4ff);
      transition: width 0.25s ease-out;
    }

    .bar .bar-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.65rem;
      color: var(--text);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
      pointer-events: none;
    }

    .main-wrapper {
      display: flex;
      flex: 1;
      gap: 1.5rem;
      padding: 1.5rem;
      box-sizing: border-box;
    }

    canvas {
      border: 3px solid var(--panel-border);
      image-rendering: pixelated;
      background: #10181f;
      flex-shrink: 0;
    }

    .panel {
      width: 260px;
      background: var(--panel-bg);
      border: 3px solid var(--panel-border);
      padding: 1.25rem;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      height: fit-content;
    }

    .panel button {
      width: 100%;
      padding: 0.75rem;
      background: transparent;
      color: var(--text);
      border: 2px solid var(--panel-border);
      cursor: pointer;
      font-family: inherit;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      transition: background 0.2s ease;
    }

    .panel button:hover,
    .panel button:focus {
      background: rgba(255, 255, 255, 0.08);
      outline: none;
    }

    .panel .worker-group {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .worker-card {
      border: 2px solid var(--panel-border);
      background: rgba(12, 14, 24, 0.6);
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .worker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .worker-header h3 {
      margin: 0;
      font-size: 0.75rem;
    }

    .worker-header .order-label {
      font-size: 0.6rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.08);
    }

    .worker-card .summary {
      font-size: 0.6rem;
      line-height: 1.4;
      color: rgba(245, 245, 248, 0.8);
    }

    .worker-actions {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.4rem;
    }

    .worker-actions button {
      font-size: 0.6rem;
      padding: 0.45rem 0.2rem;
      text-transform: uppercase;
    }

    .worker-actions button.active {
      background: rgba(103, 243, 162, 0.18);
      border-color: #67f3a2;
      color: #67f3a2;
    }

    .fsm-log {
      margin-top: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .fsm-log h3 {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      margin: 0;
    }

    #fsmLog {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 160px;
      overflow-y: auto;
      border: 2px solid var(--panel-border);
      background: rgba(12, 14, 24, 0.6);
      border-radius: 8px;
    }

    #fsmLog li {
      font-size: 0.55rem;
      padding: 0.45rem 0.6rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    #fsmLog li:last-child {
      border-bottom: none;
    }

    #textBubble {
      position: absolute;
      transform: translate(-50%, -110%);
      background: var(--bubble-bg);
      border: 2px solid #fce38a;
      padding: 0.6rem 0.9rem;
      border-radius: 6px;
      font-size: 0.74rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      max-width: 280px;
      text-align: center;
      display: none;
      pointer-events: none;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.55), 0 0 12px rgba(252, 227, 138, 0.35);
      z-index: 20;
    }

    .panel .status {
      font-size: 0.65rem;
      line-height: 1.4;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-item bar-item">
      <span class="label">Wood Stock</span>
      <div class="bar" id="woodBar">
        <div class="fill" id="woodFill"></div>
        <span class="bar-text" id="woodText">1/5</span>
      </div>
    </div>
    <div class="hud-item bar-item">
      <span class="label">Progress</span>
      <div class="bar" id="progressBar">
        <div class="fill" id="progressFill"></div>
        <span class="bar-text" id="progressText">12%</span>
      </div>
    </div>
    <div class="hud-item">
      <span class="label">Current Floor</span>
      <span class="value" id="hud-floor">1</span>
    </div>
    <div class="hud-item">
      <span class="label">Total Time</span>
      <span class="value" id="hud-time">00:00</span>
    </div>
  </div>
  <div class="main-wrapper">
    <canvas id="gameCanvas" width="1140" height="600" aria-label="mcsBuilder stage 04 playfield"></canvas>
    <aside class="panel" aria-label="control panel">
      <h2>Control Panel</h2>
      <button id="pauseBtn" type="button">Pause</button>
      <button id="speedBtn" type="button">Speed: 1×</button>
      <button id="contrastBtn" type="button">Contrast</button>
      <section class="worker-group" aria-label="worker commands">
        <div class="worker-card" data-worker="builder">
          <div class="worker-header">
            <h3>Builder</h3>
            <span class="order-label">Idle</span>
          </div>
          <p class="summary">Stamina: <span class="stamina">5.0</span> / 5 · State: <span class="state">idle</span></p>
          <div class="worker-actions">
            <button type="button" data-action="build">Build</button>
            <button type="button" data-action="rest">Rest</button>
            <button type="button" data-action="cancel">Cancel</button>
          </div>
        </div>
        <div class="worker-card" data-worker="delivery">
          <div class="worker-header">
            <h3>Delivery</h3>
            <span class="order-label">Idle</span>
          </div>
          <p class="summary">Stamina: <span class="stamina">5.0</span> / 5 · State: <span class="state">idle</span></p>
          <div class="worker-actions">
            <button type="button" data-action="fetch">Fetch</button>
            <button type="button" data-action="rest">Rest</button>
            <button type="button" data-action="cancel">Cancel</button>
          </div>
        </div>
      </section>
      <section class="fsm-log" aria-label="worker state log">
        <h3>Worker State Log</h3>
        <ul id="fsmLog" aria-live="polite"></ul>
      </section>
      <p class="status" id="panelStatus">Awaiting input…</p>
    </aside>
  </div>
  <div id="textBubble" role="status" aria-live="polite"></div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const grid = { cols: 38, rows: 20, cell: 30 };
    const FPS = 30;
    const frameDuration = 1000 / FPS;
    const MAX_STAMINA = 5;
    const STAMINA_REST_RATE = 0.25 / 1.5;
    const STAMINA_TRIP_COST = 0.35 * 1.5;
    const STAMINA_BUILD_COST = 2.5;
    const WORKER_ACTIVE_SPEED = 85;
    const WORKER_CARRY_SPEED = 75;
    const DELIVERY_LOAD_TIME = 1.1;
    const DELIVERY_DROP_TIME = 0.6;
    const WORKER_IDLE_SPEED = 28;
    const WORKER_APPROACH_BUFFER = 4;
    const PATH_REPLAN_INTERVAL = 1;
    const PATH_FAILURE_RETRY = 0.45;
    const WOOD_BASE = 10;
    const WOOD_PER_FLOOR = 5;
    const BUILD_BASE = 5;
    const BUILD_PER_FLOOR = 5;
    const BUILD_PROGRESS_SLOWDOWN = 1.5;
    const PLAYER_INTERACT_COOLDOWN = 0.35;
    const EDGE_MARGIN = 1;
    let fsmLogEl = null;

    const WorkerFSMConfig = {
      builder: {
        idle: { build: 'headingToSite', rest: 'headingToDorm', cancel: 'idle' },
        headingToSite: { arriveWork: 'building', rest: 'headingToDorm', cancel: 'idle' },
        building: { complete: 'idle', rest: 'headingToDorm', cancel: 'idle' },
        headingToDorm: { arriveRest: 'resting' },
        resting: { recovered: 'idle' }
      },
      delivery: {
        idle: { fetch: 'headingToWood', rest: 'headingToDorm', cancel: 'idle' },
        headingToWood: { arriveSource: 'loading', rest: 'headingToDorm', cancel: 'idle' },
        loading: { loadComplete: 'headingToSite', rest: 'headingToDorm', cancel: 'idle' },
        headingToSite: { arriveSite: 'delivering', rest: 'headingToDorm', cancel: 'idle' },
        delivering: { dropComplete: 'headingToWood', rest: 'headingToDorm', cancel: 'idle' },
        headingToDorm: { arriveRest: 'resting' },
        resting: { recovered: 'idle' }
      }
    };

    function createStateMachine(role) {
      return {
        role,
        state: 'idle',
        transition(event, worker) {
          const map = WorkerFSMConfig[role][this.state];
          if (!map) {
            return false;
          }
          const next = map[event];
          if (!next) {
            return false;
          }
          const previous = this.state;
          this.state = next;
          logStateTransition(worker, event, previous, next);
          return true;
        }
      };
    }

    canvas.width = grid.cols * grid.cell;
    canvas.height = grid.rows * grid.cell;

    const MCS_FLOOR_PALETTES = [
      { primary: '#303a65', secondary: '#47578c', shadow: '#1d233c' },
      { primary: '#2f4f6f', secondary: '#4b6d98', shadow: '#1a2d45' },
      { primary: '#2b5d4a', secondary: '#3f8b6b', shadow: '#162e25' },
      { primary: '#5d542b', secondary: '#8b7a3f', shadow: '#2e2716' },
      { primary: '#5d2b4b', secondary: '#8b3f6d', shadow: '#2e1625' },
      { primary: '#2b5d5b', secondary: '#3f8b87', shadow: '#162e2c' }
    ];

    const textures = {
      grass: createGrassPattern('#1f3a1c', '#2f5327', '#3f6d31'),
      mcs: createStripedPattern(
        MCS_FLOOR_PALETTES[0].primary,
        MCS_FLOOR_PALETTES[0].secondary,
        MCS_FLOOR_PALETTES[0].shadow
      ),
      building: createBrickPattern('#744d2b', '#4b321b', '#301f10'),
      cafe: createBrickPattern('#223937', '#1b2c2a', '#12201e'),
      dorm: createStripedPattern('#3e2b58', '#5b3f7a', '#211334'),
      rock: createRockPattern('#505667', '#292c36', '#8f95a6'),
      pond: createWaterPattern('#1c3558', '#2d5a8c', '#13213a')
    };

    function woodNeeded(floor) {
      return WOOD_BASE + WOOD_PER_FLOOR * (floor - 1);
    }

    function buildTimeFor(floor) {
      return BUILD_BASE + BUILD_PER_FLOOR * (floor - 1);
    }

    const zones = generateZones();
    const zoneEdgeMap = zones.map(getZoneEdgeCells);
    const zoneDirectory = zones.reduce((acc, zone, index) => {
      acc[zone.name] = { zone, edges: zoneEdgeMap[index] };
      return acc;
    }, {});
    const baseBlocked = createBlockedSetFromZones(zones);

    let playerCell = findPlayerStartCell(baseBlocked);
    const rockForbiddenCells = computeRockForbiddenCells(zones);
    const rocks = generateRocks(zones, playerCell, zoneEdgeMap, rockForbiddenCells);
    const blockedCells = createBlockedSet(zones, rocks);

    if (blockedCells.has(cellKey(playerCell))) {
      playerCell = findNearestWalkableCell(playerCell, blockedCells);
    }

    const rockTiles = buildRockTiles(rocks);
    const solidRects = [...zones, ...rockTiles];

    const state = createInitialState(playerCell, blockedCells);
    const player = state.player;
    const workers = state.workers;

    refreshMcsZoneTexture();

    const keys = {};
    let isPaused = false;
    const speedOptions = [0.5, 1, 2, 3, 4, 8, 16];
    let speedIndex = speedOptions.indexOf(1);
    state.time.speed = speedOptions[speedIndex];
    let bubbleTimeout = null;

    const statusEl = document.getElementById('panelStatus');
    const hudFloor = document.getElementById('hud-floor');
    const hudTime = document.getElementById('hud-time');
    const woodFill = document.getElementById('woodFill');
    const woodText = document.getElementById('woodText');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const bubble = document.getElementById('textBubble');
    const workerCards = Array.from(document.querySelectorAll('.worker-card'));
    fsmLogEl = document.getElementById('fsmLog');
    bubble.style.display = 'none';

    function rectsOverlap(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function expandedRect(rect, padding) {
      return {
        x: rect.x - padding,
        y: rect.y - padding,
        width: rect.width + padding * 2,
        height: rect.height + padding * 2
      };
    }

    function cellKey(cell) {
      return `${cell.col},${cell.row}`;
    }

    function pointToCell(point) {
      const col = clamp(Math.floor(point.x / grid.cell), 0, grid.cols - 1);
      const row = clamp(Math.floor(point.y / grid.cell), 0, grid.rows - 1);
      return { col, row };
    }

    function cellToCenter(cell) {
      return {
        x: cell.col * grid.cell + grid.cell / 2,
        y: cell.row * grid.cell + grid.cell / 2
      };
    }

    function cellsEqual(a, b) {
      return a && b && a.col === b.col && a.row === b.row;
    }

    function parseCellKey(key) {
      const [col, row] = key.split(',').map(Number);
      return { col, row };
    }

    function heuristic(a, b) {
      return Math.abs(a.col - b.col) + Math.abs(a.row - b.row);
    }

    function computeDynamicBlockers(worker, goalKey) {
      const blocked = new Set();
      workers.forEach(other => {
        if (other === worker || !other.visible) {
          return;
        }
        const cell = pointToCell(workerCenter(other));
        const key = cellKey(cell);
        if (key !== goalKey) {
          blocked.add(key);
        }
      });
      const playerCellKey = cellKey(pointToCell({ x: player.x + player.width / 2, y: player.y + player.height / 2 }));
      if (playerCellKey !== goalKey) {
        blocked.add(playerCellKey);
      }
      return blocked;
    }

    function findPath(start, goal, worker) {
      const startKey = cellKey(start);
      const goalKey = cellKey(goal);
      if (startKey === goalKey) {
        return [goal];
      }
      if (blockedCells.has(startKey) && startKey !== goalKey) {
        return null;
      }

      const dynamicBlockers = computeDynamicBlockers(worker, goalKey);
      let path = findPathWithBlockers(start, goal, goalKey, dynamicBlockers);
      if (!path && dynamicBlockers.size > 0) {
        path = findPathWithBlockers(start, goal, goalKey, null);
      }
      return path;
    }

    function findPathWithBlockers(start, goal, goalKey, dynamicBlockers) {
      const open = new Map();
      const openList = [];
      const cameFrom = new Map();
      const gScore = new Map();

      const startKey = cellKey(start);
      gScore.set(startKey, 0);
      const startNode = { cell: start, key: startKey, f: heuristic(start, goal) };
      open.set(startKey, startNode);
      openList.push(startNode);

      while (openList.length > 0) {
        openList.sort((a, b) => a.f - b.f);
        const current = openList.shift();
        open.delete(current.key);

        if (current.key === goalKey) {
          return reconstructPath(cameFrom, current.key);
        }

        const neighbors = [
          { col: current.cell.col + 1, row: current.cell.row },
          { col: current.cell.col - 1, row: current.cell.row },
          { col: current.cell.col, row: current.cell.row + 1 },
          { col: current.cell.col, row: current.cell.row - 1 }
        ];

        neighbors.forEach(neighbor => {
          if (!withinGrid(neighbor.col, neighbor.row)) {
            return;
          }
          const neighborKey = cellKey(neighbor);
          if (dynamicBlockers && dynamicBlockers.has(neighborKey) && neighborKey !== goalKey) {
            return;
          }
          if (blockedCells.has(neighborKey) && neighborKey !== goalKey) {
            return;
          }
          const currentG = gScore.has(current.key) ? gScore.get(current.key) : Infinity;
          const tentativeG = currentG + 1;
          const neighborBest = gScore.has(neighborKey) ? gScore.get(neighborKey) : Infinity;
          if (tentativeG >= neighborBest) {
            return;
          }
          cameFrom.set(neighborKey, current.key);
          gScore.set(neighborKey, tentativeG);
          const fScore = tentativeG + heuristic(neighbor, goal);
          const existing = open.get(neighborKey);
          if (existing) {
            existing.f = fScore;
          } else {
            const node = { cell: neighbor, key: neighborKey, f: fScore };
            open.set(neighborKey, node);
            openList.push(node);
          }
        });
      }

      return null;
    }

    function reconstructPath(cameFrom, goalKey) {
      const path = [];
      let currentKey = goalKey;
      while (currentKey) {
        path.push(parseCellKey(currentKey));
        currentKey = cameFrom.get(currentKey);
      }
      return path.reverse();
    }

    function getPlayerRect() {
      return {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };
    }

    function getWorkerRects(options = {}) {
      const { exclude } = options;
      return workers
        .filter(worker => worker !== exclude && worker.visible)
        .map(worker => ({
          x: worker.x,
          y: worker.y,
          width: worker.width,
          height: worker.height
        }));
    }

    function getCollisionRects(options = {}) {
      const { includeWorkers = true, excludeWorker = null, includePlayer = false } = options;
      const rects = [...solidRects];
      if (includeWorkers) {
        rects.push(...getWorkerRects({ exclude: excludeWorker }));
      }
      if (includePlayer) {
        rects.push(getPlayerRect());
      }
      return rects;
    }

    function getZoneInfo(name) {
      return zoneDirectory[name] || null;
    }

    function getApproachCenter(name) {
      const info = getZoneInfo(name);
      if (!info) {
        return null;
      }
      for (const cell of info.edges) {
        if (!blockedCells.has(cellKey(cell))) {
          return {
            x: cell.col * grid.cell + grid.cell / 2,
            y: cell.row * grid.cell + grid.cell / 2
          };
        }
      }
      if (info.edges.length > 0) {
        const fallback = info.edges[0];
        const col = clamp(fallback.col, 0, grid.cols - 1);
        const row = clamp(fallback.row, 0, grid.rows - 1);
        return {
          x: col * grid.cell + grid.cell / 2,
          y: row * grid.cell + grid.cell / 2
        };
      }
      return {
        x: info.zone.x + info.zone.width / 2,
        y: info.zone.y + info.zone.height / 2
      };
    }

    function workerCenter(worker) {
      return {
        x: worker.x + worker.width / 2,
        y: worker.y + worker.height / 2
      };
    }

    function alignWorkerToCenter(worker, center) {
      if (!center) return;
      worker.x = center.x - worker.width / 2;
      worker.y = center.y - worker.height / 2;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
      const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
      return `${mins}:${secs}`;
    }

    function logStateTransition(worker, event, fromState, toState) {
      if (!fsmLogEl) {
        return;
      }
      const label = worker ? worker.name : 'Worker';
      const timestamp = formatTime(state.time.elapsed || 0);
      const entry = document.createElement('li');
      entry.textContent = `[${timestamp}] ${label}: ${fromState} —${event}→ ${toState}`;
      fsmLogEl.prepend(entry);
      while (fsmLogEl.children.length > 8) {
        fsmLogEl.removeChild(fsmLogEl.lastChild);
      }
    }


    function updateHUD() {
      hudFloor.textContent = `${state.floor.n}`;
      const need = state.floor.need || 1;
      const woodRatio = Math.max(0, Math.min(1, state.stock.wood / need));
      const woodAmount = Number.isInteger(state.stock.wood)
        ? state.stock.wood
        : state.stock.wood.toFixed(1);
      woodText.textContent = `${woodAmount}/${need}`;
      woodFill.style.width = `${woodRatio * 100}%`;
      const progressPercent = Math.max(0, Math.min(1, state.floor.progress)) * 100;
      progressText.textContent = `${Math.round(progressPercent)}%`;
      progressFill.style.width = `${progressPercent}%`;
      hudTime.textContent = formatTime(state.time.elapsed);
    }

    function createGrassPattern(primary, secondary, accent) {
      const tile = document.createElement('canvas');
      tile.width = 16;
      tile.height = 16;
      const tctx = tile.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = primary;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = secondary;
      for (let y = 0; y < tile.height; y += 4) {
        for (let x = (y / 4) % 2 === 0 ? 0 : 2; x < tile.width; x += 4) {
          tctx.fillRect(x, y, 2, 2);
        }
      }
      tctx.fillStyle = accent;
      const accentPixels = [
        [1, 1], [5, 3], [9, 1], [13, 5],
        [3, 9], [11, 11], [7, 13], [15, 15]
      ];
      accentPixels.forEach(([x, y]) => {
        tctx.fillRect(x % tile.width, y % tile.height, 2, 2);
      });
      return ctx.createPattern(tile, 'repeat');
    }

    function createStripedPattern(primary, secondary, shadow) {
      const tile = document.createElement('canvas');
      tile.width = 16;
      tile.height = 16;
      const tctx = tile.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = shadow;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = primary;
      for (let x = 0; x < tile.width; x += 4) {
        tctx.fillRect(x, 0, 3, tile.height);
      }
      tctx.fillStyle = secondary;
      for (let y = 0; y < tile.height; y += 8) {
        tctx.fillRect(0, y, tile.width, 2);
      }
      return ctx.createPattern(tile, 'repeat');
    }

    function createBrickPattern(base, mortar, shadow) {
      const tile = document.createElement('canvas');
      tile.width = 16;
      tile.height = 16;
      const tctx = tile.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = shadow;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = mortar;
      tctx.fillRect(1, 1, tile.width - 2, tile.height - 2);
      tctx.fillStyle = base;
      for (let row = 0; row < tile.height; row += 6) {
        const offset = (row / 6) % 2 === 0 ? 0 : 4;
        for (let col = offset; col < tile.width; col += 8) {
          tctx.fillRect(col, row, 6, 4);
        }
      }
      tctx.fillStyle = shadow;
      for (let y = 0; y < tile.height; y += 4) {
        tctx.fillRect(0, y, tile.width, 1);
      }
      return ctx.createPattern(tile, 'repeat');
    }

    function createRockPattern(primary, shadow, highlight) {
      const tile = document.createElement('canvas');
      tile.width = 16;
      tile.height = 16;
      const tctx = tile.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = shadow;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = primary;
      const blocks = [
        [2, 2, 4, 4], [8, 1, 5, 5], [1, 9, 6, 5]
      ];
      blocks.forEach(([x, y, w, h]) => {
        tctx.fillRect(x, y, w, h);
      });
      tctx.fillStyle = highlight;
      [[3, 3], [9, 3], [5, 11]].forEach(([x, y]) => {
        tctx.fillRect(x, y, 2, 2);
      });
      return ctx.createPattern(tile, 'repeat');
    }

    function createWaterPattern(base, ripple, highlight) {
      const tile = document.createElement('canvas');
      tile.width = 16;
      tile.height = 16;
      const tctx = tile.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = base;
      tctx.fillRect(0, 0, tile.width, tile.height);
      tctx.fillStyle = ripple;
      for (let y = 0; y < tile.height; y += 4) {
        tctx.fillRect(0, y, tile.width, 2);
      }
      tctx.fillStyle = highlight;
      for (let x = 0; x < tile.width; x += 6) {
        tctx.fillRect(x, (x % 2 === 0 ? 3 : 1), 3, 1);
      }
      return ctx.createPattern(tile, 'repeat');
    }

    function getMcsPatternForFloorsBuilt(floorsBuilt) {
      const paletteIndex = ((floorsBuilt % MCS_FLOOR_PALETTES.length) + MCS_FLOOR_PALETTES.length) % MCS_FLOOR_PALETTES.length;
      const palette = MCS_FLOOR_PALETTES[paletteIndex] || MCS_FLOOR_PALETTES[0];
      return createStripedPattern(palette.primary, palette.secondary, palette.shadow);
    }

    function refreshMcsZoneTexture() {
      const info = zoneDirectory['MCS Construction'];
      if (!info || !state || !state.floor) {
        return;
      }
      const builtFloors = Math.max(0, state.floor.n - 1);
      const pattern = getMcsPatternForFloorsBuilt(builtFloors);
      info.zone.color = pattern;
      textures.mcs = pattern;
    }

    function generateZones() {
      const placed = [];
      const zones = [];

      const configs = [
        {
          name: 'MCS Construction',
          description: 'Future site of the Computer Science building.',
          tilesWide: 5,
          tilesHigh: 5,
          color: textures.mcs,
          padding: grid.cell
        },
        {
          name: 'Wood House',
          description: 'Stockpile for framing lumber.',
          tilesWide: 2,
          tilesHigh: 2,
          color: textures.building,
          padding: grid.cell * 0.75
        },
        {
          name: 'Starbucks',
          description: 'Quick caffeine stop for the crew.',
          tilesWide: 2,
          tilesHigh: 2,
          color: textures.cafe,
          padding: grid.cell * 0.75
        },
        {
          name: 'Dorm Beds',
          description: 'Where exhausted workers rest up.',
          tilesWide: 2,
          tilesHigh: 2,
          color: textures.dorm,
          padding: grid.cell * 0.75
        }
      ];

      configs.forEach(config => {
        const zone = placeRandomZone(config, placed, config.padding);
        zones.push(zone);
        placed.push(zone);
      });

      return zones;
    }

    function computeRockForbiddenCells(zones) {
      const forbidden = new Set();
      const margin = 1;
      zones.forEach(zone => {
        const startCol = Math.floor(zone.x / grid.cell);
        const startRow = Math.floor(zone.y / grid.cell);
        const cols = Math.floor(zone.width / grid.cell);
        const rows = Math.floor(zone.height / grid.cell);
        for (let col = startCol - margin; col < startCol + cols + margin; col++) {
          for (let row = startRow - margin; row < startRow + rows + margin; row++) {
            if (withinGrid(col, row)) {
              forbidden.add(cellKey({ col, row }));
            }
          }
        }
      });
      return forbidden;
    }

    function placeRandomZone(config, placed, padding) {
      const width = config.tilesWide * grid.cell;
      const height = config.tilesHigh * grid.cell;
      let minCol = EDGE_MARGIN;
      let minRow = EDGE_MARGIN;
      let maxCol = grid.cols - config.tilesWide - EDGE_MARGIN;
      let maxRow = grid.rows - config.tilesHigh - EDGE_MARGIN;

      if (maxCol < minCol) {
        minCol = 0;
        maxCol = grid.cols - config.tilesWide;
      }
      if (maxRow < minRow) {
        minRow = 0;
        maxRow = grid.rows - config.tilesHigh;
      }

      let attempts = 0;

      while (attempts < 400) {
        const col = getRandomInt(minCol, maxCol);
        const row = getRandomInt(minRow, maxRow);
        const zone = {
          name: config.name,
          description: config.description,
          x: col * grid.cell,
          y: row * grid.cell,
          width,
          height,
          color: config.color,
          solid: true
        };

        const overlaps = placed.some(existing => rectsOverlap(zone, expandedRect(existing, padding)));
        if (!overlaps) {
          return zone;
        }
        attempts += 1;
      }

      const fallbackCol = Math.max(minCol, Math.min(maxCol, EDGE_MARGIN));
      const fallbackRow = Math.max(minRow, Math.min(maxRow, EDGE_MARGIN));

      return {
        name: config.name,
        description: config.description,
        x: fallbackCol * grid.cell,
        y: fallbackRow * grid.cell,
        width,
        height,
        color: config.color,
        solid: true
      };
    }

    function createBlockedSetFromZones(zones) {
      const set = new Set();
      zones.forEach(zone => markZoneCells(set, zone));
      return set;
    }

    function createBlockedSet(zones, rocks) {
      const set = createBlockedSetFromZones(zones);
      rocks.forEach(rock => {
        rock.cells.forEach(cell => set.add(cellKey(cell)));
      });
      return set;
    }

    function markZoneCells(set, zone) {
      const startCol = Math.floor(zone.x / grid.cell);
      const startRow = Math.floor(zone.y / grid.cell);
      const cols = Math.floor(zone.width / grid.cell);
      const rows = Math.floor(zone.height / grid.cell);
      for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows; r++) {
          set.add(cellKey({ col: startCol + c, row: startRow + r }));
        }
      }
    }

    function findPlayerStartCell(blockedSet) {
      const preferred = { col: Math.floor(grid.cols / 2), row: grid.rows - 2 };
      if (!blockedSet.has(cellKey(preferred))) {
        return preferred;
      }
      return findNearestWalkableCell(preferred, blockedSet);
    }

    function findNearestWalkableCell(start, blockedSet) {
      const queue = [start];
      const visited = new Set([cellKey(start)]);

      while (queue.length > 0) {
        const cell = queue.shift();
        const key = cellKey(cell);
        if (withinGrid(cell.col, cell.row) && !blockedSet.has(key)) {
          return cell;
        }

        const neighbors = [
          { col: cell.col + 1, row: cell.row },
          { col: cell.col - 1, row: cell.row },
          { col: cell.col, row: cell.row + 1 },
          { col: cell.col, row: cell.row - 1 }
        ];

        neighbors.forEach(neighbor => {
          const nKey = cellKey(neighbor);
          if (!visited.has(nKey) && withinGrid(neighbor.col, neighbor.row)) {
            visited.add(nKey);
            queue.push(neighbor);
          }
        });
      }

      return { col: 1, row: 1 };
    }

    function withinGrid(col, row) {
      return col >= 0 && row >= 0 && col < grid.cols && row < grid.rows;
    }

    function generateRocks(zones, startCell, zoneEdgeMap, forbiddenCells = new Set()) {
      const occupancy = createBlockedSetFromZones(zones);
      const rocks = [];
      const rockCount = getRandomInt(9, 15);
      const shapeTypes = ['rectangle', 'square', 'circle'];

      for (let i = 0; i < rockCount; i++) {
        let placed = false;
        let attempts = 0;

        while (!placed && attempts < 350) {
          attempts += 1;
          const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
          let cells = [];

          if (type === 'rectangle') {
            const width = getRandomInt(3, 6);
            const height = getRandomInt(2, 4);
            const maxCol = grid.cols - width;
            const maxRow = grid.rows - height;
            if (maxCol < 0 || maxRow < 0) continue;
            const originCol = getRandomInt(0, maxCol);
            const originRow = getRandomInt(0, maxRow);
            for (let dx = 0; dx < width; dx++) {
              for (let dy = 0; dy < height; dy++) {
                cells.push({ col: originCol + dx, row: originRow + dy });
              }
            }
          } else if (type === 'square') {
            const size = getRandomInt(2, 4);
            const maxCol = grid.cols - size;
            const maxRow = grid.rows - size;
            if (maxCol < 0 || maxRow < 0) continue;
            const originCol = getRandomInt(0, maxCol);
            const originRow = getRandomInt(0, maxRow);
            for (let dx = 0; dx < size; dx++) {
              for (let dy = 0; dy < size; dy++) {
                cells.push({ col: originCol + dx, row: originRow + dy });
              }
            }
          } else {
            const radius = getRandomInt(1, 2);
            const diameter = radius * 2 + 1;
            const maxCol = grid.cols - diameter;
            const maxRow = grid.rows - diameter;
            if (maxCol < 0 || maxRow < 0) continue;
            const originCol = getRandomInt(0, maxCol);
            const originRow = getRandomInt(0, maxRow);
            const centerCol = originCol + radius;
            const centerRow = originRow + radius;
            for (let col = originCol; col < originCol + diameter; col++) {
              for (let row = originRow; row < originRow + diameter; row++) {
                const dx = col - centerCol;
                const dy = row - centerRow;
                if (dx * dx + dy * dy <= radius * radius + 0.4) {
                  cells.push({ col, row });
                }
              }
            }
          }

          if (!cells.length) continue;
          if (cells.some(cell => !withinGrid(cell.col, cell.row))) continue;
          if (cells.some(cell => cell.col <= 0 || cell.row <= 0 || cell.col >= grid.cols - 1 || cell.row >= grid.rows - 1)) continue;
          if (cells.some(cell => forbiddenCells.has(cellKey(cell)))) continue;
          if (cells.some(cell => occupancy.has(cellKey(cell)))) continue;
          if (cells.some(cell => cell.col === startCell.col && cell.row === startCell.row)) continue;

          cells.forEach(cell => occupancy.add(cellKey(cell)));

          if (ensureConnectivity(occupancy, startCell, zoneEdgeMap)) {
            let kind = 'rock';
            if (type === 'rectangle' && Math.random() < 0.45) {
              kind = 'pond';
            } else if (type === 'circle') {
              kind = 'fountain';
            }
            rocks.push({ cells, kind });
            placed = true;
          } else {
            cells.forEach(cell => occupancy.delete(cellKey(cell)));
          }
        }
      }

      return rocks;
    }

    function ensureConnectivity(occupancy, startCell, zoneEdgeMap) {
      if (!withinGrid(startCell.col, startCell.row) || occupancy.has(cellKey(startCell))) {
        return false;
      }
      const reachable = floodFill(occupancy, startCell);
      return zoneEdgeMap.every(edges => edges.some(cell => {
        const key = cellKey(cell);
        return !occupancy.has(key) && reachable.has(key);
      }));
    }

    function floodFill(occupancy, startCell) {
      const visited = new Set();
      const queue = [];
      const startKey = cellKey(startCell);
      queue.push(startCell);
      visited.add(startKey);

      while (queue.length) {
        const cell = queue.shift();
        const neighbors = [
          { col: cell.col + 1, row: cell.row },
          { col: cell.col - 1, row: cell.row },
          { col: cell.col, row: cell.row + 1 },
          { col: cell.col, row: cell.row - 1 }
        ];

        neighbors.forEach(neighbor => {
          const key = cellKey(neighbor);
          if (!visited.has(key) && withinGrid(neighbor.col, neighbor.row) && !occupancy.has(key)) {
            visited.add(key);
            queue.push(neighbor);
          }
        });
      }

      return visited;
    }

    function getZoneEdgeCells(zone) {
      const cells = [];
      const startCol = Math.floor(zone.x / grid.cell);
      const startRow = Math.floor(zone.y / grid.cell);
      const cols = Math.floor(zone.width / grid.cell);
      const rows = Math.floor(zone.height / grid.cell);

      for (let col = startCol; col < startCol + cols; col++) {
        cells.push({ col, row: startRow - 1 });
        cells.push({ col, row: startRow + rows });
      }
      for (let row = startRow; row < startRow + rows; row++) {
        cells.push({ col: startCol - 1, row });
        cells.push({ col: startCol + cols, row });
      }

      const unique = new Map();
      cells.forEach(cell => {
        if (withinGrid(cell.col, cell.row)) {
          unique.set(cellKey(cell), cell);
        }
      });
      return Array.from(unique.values());
    }

    function buildRockTiles(rocks) {
      const tiles = [];
      rocks.forEach(rock => {
        rock.cells.forEach(cell => {
          tiles.push({
            x: cell.col * grid.cell,
            y: cell.row * grid.cell,
            width: grid.cell,
            height: grid.cell,
            solid: true
          });
        });
      });
      return tiles;
    }

    function createPlayer(cell) {
      const width = 26;
      const height = 26;
      return {
        x: cell.col * grid.cell + (grid.cell - width) / 2,
        y: cell.row * grid.cell + (grid.cell - height) / 2,
        width,
        height,
        speed: 150,
        color: '#f9f871',
        item: 'none',
        cooldown: 0
      };
    }

    function createWorkers(playerCell, blocked) {
      const builderCell = findWorkerCell({ col: playerCell.col - 2, row: playerCell.row - 1 }, blocked);
      const deliveryCell = findWorkerCell({ col: playerCell.col + 2, row: playerCell.row - 1 }, blocked);
      return [
        createWorker('W1', 'builder', 'Builder', builderCell, '#777d8a', '#f4a261', '#ffe082'),
        createWorker('W2', 'delivery', 'Delivery', deliveryCell, '#868d9a', '#58d4ff', '#a8e8ff')
      ];
    }

    function createInitialState(playerCell, blocked) {
      const player = createPlayer(playerCell);
      const workers = createWorkers(playerCell, blocked);
      return {
        time: { elapsed: 0, speed: 1 },
        floor: { n: 1, progress: 0, need: woodNeeded(1), buildTime: buildTimeFor(1) },
        stock: { wood: 2 },
        player,
        workers
      };
    }

    function findWorkerCell(preferred, blocked) {
      if (!preferred || !withinGrid(preferred.col, preferred.row) || blocked.has(cellKey(preferred))) {
        return findNearestWalkableCell(preferred || { col: 2, row: 2 }, blocked);
      }
      return preferred;
    }

    function createWorker(id, role, name, cell, idleColor, activeColor, accentColor) {
      const width = 20;
      const height = 20;
      return {
        id,
        role,
        name,
        stateMachine: createStateMachine(role),
        x: cell.col * grid.cell + (grid.cell - width) / 2,
        y: cell.row * grid.cell + (grid.cell - height) / 2,
        width,
        height,
        colorIdle: idleColor,
        colorActive: activeColor,
        accentColor,
        order: 'idle',
        stamina: MAX_STAMINA,
        inv: 0,
        orderStarted: false,
        tripTimer: 0,
        idleSpeed: WORKER_IDLE_SPEED,
        idleCooldown: Math.random() * 1.5,
        target: null,
        path: null,
        pathIndex: 0,
        pathGoal: null,
        pathNeedsRecalc: false,
        pathReplanTimer: 0,
        pathBlocked: false,
        pathFailureCooldown: 0,
        jumping: false,
        jumpTime: 0,
        jumpDuration: 0.45,
        jumpHeight: 12,
        jumpOffset: 0,
        hasJumped: false,
        activity: 'idle',
        visible: true,
        buildReserved: false,
        restAnchor: null,
        taskTimer: 0
      };
    }

    function handleMovement(dt) {
      let vx = 0;
      let vy = 0;
      if (keys['KeyW']) vy -= 1;
      if (keys['KeyS']) vy += 1;
      if (keys['KeyA']) vx -= 1;
      if (keys['KeyD']) vx += 1;

      if (vx !== 0 && vy !== 0) {
        const inv = Math.SQRT1_2;
        vx *= inv;
        vy *= inv;
      }

      const distance = player.speed * dt * state.time.speed;

      const collisionRects = getCollisionRects();

      if (vx !== 0) {
        const nextRect = {
          x: player.x + vx * distance,
          y: player.y,
          width: player.width,
          height: player.height
        };
        if (!collisionRects.some(s => rectsOverlap(nextRect, s))) {
          player.x = nextRect.x;
        }
      }

      if (vy !== 0) {
        const nextRect = {
          x: player.x,
          y: player.y + vy * distance,
          width: player.width,
          height: player.height
        };
        if (!collisionRects.some(s => rectsOverlap(nextRect, s))) {
          player.y = nextRect.y;
        }
      }

      player.x = clamp(player.x, 2, canvas.width - player.width - 2);
      player.y = clamp(player.y, 2, canvas.height - player.height - 2);
    }

    function updateWorkers(dt) {
      const scaledDt = dt * state.time.speed;
      workers.forEach(worker => {
        worker.pathReplanTimer += scaledDt;
        if (worker.pathFailureCooldown > 0) {
          worker.pathFailureCooldown = Math.max(0, worker.pathFailureCooldown - scaledDt);
        }
        if (worker.target || (worker.path && worker.path.length > 0)) {
          if (worker.pathReplanTimer >= PATH_REPLAN_INTERVAL) {
            worker.pathNeedsRecalc = true;
            worker.pathReplanTimer = 0;
          }
        } else {
          worker.pathReplanTimer = 0;
        }

        processWorkerOrder(worker, scaledDt);

        if (worker.order === 'idle' && worker.visible && !worker.hasJumped) {
          triggerIdleJump(worker);
        }

        if (worker.jumping) {
          worker.jumpTime += scaledDt;
          const jumpProgress = Math.min(worker.jumpTime / worker.jumpDuration, 1);
          worker.jumpOffset = Math.sin(jumpProgress * Math.PI) * worker.jumpHeight;
          if (jumpProgress >= 1) {
            worker.jumping = false;
            worker.jumpOffset = 0;
          }
        }

        if (worker.order === 'idle' && worker.visible) {
          if (worker.idleCooldown > 0) {
            worker.idleCooldown -= scaledDt;
          } else if (!worker.target) {
            const target = pickTargetCell(worker, blockedCells);
            if (target) {
              setWorkerDestination(worker, target);
            }
            worker.idleCooldown = Math.random() * 1.5 + 0.5;
          }

          if (worker.target) {
            const reached = moveWorkerToward(worker, worker.target, worker.idleSpeed, scaledDt);
            if (reached) {
              setWorkerDestination(worker, null);
            }
          }
        }
      });
    }

    function processWorkerOrder(worker, dt) {
      if (worker.order === 'rest') {
        handleRest(worker, dt);
        return;
      }

      if (worker.order === 'idle') {
        worker.activity = 'idle';
        worker.orderStarted = false;
        worker.buildReserved = false;
        worker.taskTimer = 0;
        return;
      }

      if (worker.stamina <= 0) {
        setWorkerOrder(worker, 'rest', `${worker.name} heads to the dorm to recover.`);
        return;
      }

      if (worker.role === 'builder' && worker.order === 'build') {
        handleBuilder(worker, dt);
      } else if (worker.role === 'delivery' && worker.order === 'deliver') {
        handleDelivery(worker, dt);
      }
    }

    function handleBuilder(worker, dt) {
      const approach = getApproachCenter('MCS Construction');
      if (!approach) {
        return;
      }

      if (worker.activity !== 'toSite' && worker.activity !== 'building') {
        worker.activity = 'toSite';
        setWorkerDestination(worker, approach);
      }

      if (worker.activity === 'toSite') {
        const arrived = moveWorkerToward(worker, approach, WORKER_ACTIVE_SPEED, dt);
        if (arrived) {
          alignWorkerToCenter(worker, approach);
          worker.stateMachine.transition('arriveWork', worker);
          setWorkerDestination(worker, null);
          worker.activity = 'building';
          if (!worker.buildReserved) {
            if (state.stock.wood < state.floor.need) {
              setWorkerOrder(worker, 'idle', 'Need more wood before building.');
              return;
            }
            if (worker.stamina < STAMINA_BUILD_COST) {
              setWorkerOrder(worker, 'rest', `${worker.name} needs rest before building.`);
              return;
            }
            state.stock.wood = Math.max(0, state.stock.wood - state.floor.need);
            worker.stamina = Math.max(0, worker.stamina - STAMINA_BUILD_COST);
            worker.buildReserved = true;
          }
        }
        return;
      }

      if (worker.activity === 'building') {
        if (!worker.buildReserved) {
          worker.activity = 'toSite';
          setWorkerDestination(worker, approach);
          return;
        }
        const progressGain = dt / (state.floor.buildTime * BUILD_PROGRESS_SLOWDOWN);
        state.floor.progress = Math.min(1, state.floor.progress + progressGain);
        if (state.floor.progress >= 1) {
          worker.buildReserved = false;
          completeFloor();
          worker.stateMachine.transition('complete', worker);
          if (worker.stamina < STAMINA_BUILD_COST) {
            setWorkerOrder(worker, 'rest', `${worker.name} completes the floor and heads to the dorm.`);
          } else {
            setWorkerOrder(worker, 'idle', `${worker.name} completes the floor!`);
          }
        }
      }
    }

    function handleDelivery(worker, dt) {
      const woodApproach = getApproachCenter('Wood House');
      const mcsApproach = getApproachCenter('MCS Construction');
      if (!woodApproach || !mcsApproach) {
        return;
      }

      if (!['toWood', 'loading', 'toMcs', 'delivering'].includes(worker.activity)) {
        worker.activity = 'toWood';
        setWorkerDestination(worker, woodApproach);
      }

      if (worker.activity === 'toWood') {
        const arrived = moveWorkerToward(worker, woodApproach, WORKER_ACTIVE_SPEED, dt);
        if (arrived) {
          alignWorkerToCenter(worker, woodApproach);
          worker.stateMachine.transition('arriveSource', worker);
          worker.activity = 'loading';
          worker.taskTimer = 0;
          setWorkerDestination(worker, null);
        }
        return;
      }

      if (worker.activity === 'loading') {
        worker.taskTimer += dt;
        if (worker.taskTimer >= DELIVERY_LOAD_TIME) {
          worker.taskTimer = 0;
          const remaining = Math.max(0, state.floor.need - state.stock.wood);
          if (remaining <= 0) {
            setWorkerOrder(worker, 'idle', 'Wood stock is full for this floor.');
            return;
          }
          worker.inv = Math.min(1, remaining);
          worker.stateMachine.transition('loadComplete', worker);
          worker.activity = 'toMcs';
          setWorkerDestination(worker, mcsApproach);
        }
        return;
      }

      if (worker.activity === 'toMcs') {
        const arrived = moveWorkerToward(worker, mcsApproach, WORKER_CARRY_SPEED, dt);
        if (arrived) {
          alignWorkerToCenter(worker, mcsApproach);
          worker.stateMachine.transition('arriveSite', worker);
          worker.activity = 'delivering';
          worker.taskTimer = 0;
        }
        return;
      }

      if (worker.activity === 'delivering') {
        worker.taskTimer += dt;
        if (worker.taskTimer >= DELIVERY_DROP_TIME) {
          worker.taskTimer = 0;
          if (worker.inv <= 0) {
            worker.activity = 'toWood';
            setWorkerDestination(worker, woodApproach);
            return;
          }
          const room = Math.max(0, state.floor.need - state.stock.wood);
          if (room <= 0) {
            worker.activity = 'toWood';
            setWorkerDestination(worker, woodApproach);
            setWorkerOrder(worker, 'idle', 'Wood stock is full for this floor.');
            return;
          }
          const delivered = Math.min(worker.inv, room);
          state.stock.wood = Math.min(state.floor.need, state.stock.wood + delivered);
          worker.inv -= delivered;
          worker.stateMachine.transition('dropComplete', worker);
          worker.stamina = Math.max(0, worker.stamina - STAMINA_TRIP_COST);
          statusEl.textContent = `${worker.name} delivered ${delivered} wood.`;
          if (worker.stamina <= 0) {
            setWorkerOrder(worker, 'rest', `${worker.name} is exhausted and heads to the dorm.`);
            return;
          }
          worker.activity = 'toWood';
          setWorkerDestination(worker, woodApproach);
        }
      }
    }

    function handleRest(worker, dt) {
      const dormApproach = getApproachCenter('Dorm Beds');
      if (!dormApproach) {
        return;
      }

      if (worker.activity !== 'toDorm' && worker.activity !== 'resting') {
        worker.activity = 'toDorm';
        worker.visible = true;
        setWorkerDestination(worker, dormApproach);
        worker.restAnchor = dormApproach;
      }

      if (worker.activity === 'toDorm') {
        const arrived = moveWorkerToward(worker, dormApproach, WORKER_ACTIVE_SPEED, dt);
        if (arrived) {
          alignWorkerToCenter(worker, dormApproach);
          worker.stateMachine.transition('arriveRest', worker);
          setWorkerDestination(worker, null);
          worker.activity = 'resting';
          worker.visible = false;
        }
        return;
      }

      if (worker.activity === 'resting') {
        worker.stamina = Math.min(MAX_STAMINA, worker.stamina + STAMINA_REST_RATE * dt);
        if (worker.stamina >= MAX_STAMINA - 0.01) {
          worker.stamina = MAX_STAMINA;
          worker.visible = true;
          if (worker.restAnchor) {
            alignWorkerToCenter(worker, worker.restAnchor);
          }
          worker.stateMachine.transition('recovered', worker);
          setWorkerOrder(worker, 'idle', `${worker.name} feels refreshed and leaves the dorm.`);
        }
      }
    }

    function completeFloor() {
      const finished = state.floor.n;
      state.floor.n += 1;
      state.floor.progress = 0;
      state.floor.need = woodNeeded(state.floor.n);
      state.floor.buildTime = buildTimeFor(state.floor.n);
      state.stock.wood = Math.min(state.stock.wood, state.floor.need);
      refreshMcsZoneTexture();
      statusEl.textContent = `Floor ${finished} complete! Preparing materials for floor ${state.floor.n}.`;
      showBubble(`Floor ${finished} complete!`);
    }

    function triggerIdleJump(worker) {
      worker.hasJumped = true;
      worker.jumping = true;
      worker.jumpTime = 0;
    }

    function pickTargetCell(worker, blocked) {
      const baseCol = Math.round((worker.x + worker.width / 2) / grid.cell);
      const baseRow = Math.round((worker.y + worker.height / 2) / grid.cell);

      for (let attempt = 0; attempt < 20; attempt++) {
        const offsetCol = getRandomInt(-4, 4);
        const offsetRow = getRandomInt(-3, 3);
        const col = baseCol + offsetCol;
        const row = baseRow + offsetRow;
        if (!withinGrid(col, row)) continue;
        const key = `${col},${row}`;
        if (blocked.has(key)) continue;
        return {
          x: col * grid.cell + grid.cell / 2,
          y: row * grid.cell + grid.cell / 2
        };
      }

      return null;
    }

    function moveWorker(worker, dx, dy) {
      let moved = false;
      const collisionRects = getCollisionRects({ includeWorkers: true, excludeWorker: worker, includePlayer: true });

      if (dx !== 0) {
        const nextRect = {
          x: worker.x + dx,
          y: worker.y,
          width: worker.width,
          height: worker.height
        };
        if (!collisionRects.some(s => rectsOverlap(nextRect, s))) {
          worker.x = nextRect.x;
          moved = true;
        } else if (Math.abs(dx) > 0.01) {
          worker.pathNeedsRecalc = true;
          worker.pathReplanTimer = 0;
        }
      }

      if (dy !== 0) {
        const nextRect = {
          x: worker.x,
          y: worker.y + dy,
          width: worker.width,
          height: worker.height
        };
        if (!collisionRects.some(s => rectsOverlap(nextRect, s))) {
          worker.y = nextRect.y;
          moved = true;
        } else if (Math.abs(dy) > 0.01) {
          worker.pathNeedsRecalc = true;
          worker.pathReplanTimer = 0;
        }
      }

      worker.x = clamp(worker.x, 2, canvas.width - worker.width - 2);
      worker.y = clamp(worker.y, 2, canvas.height - worker.height - 2);
      return moved;
    }

    function moveTowardPoint(worker, target, speed, dt) {
      const center = workerCenter(worker);
      const dx = target.x - center.x;
      const dy = target.y - center.y;
      const distance = Math.hypot(dx, dy);
      if (distance <= WORKER_APPROACH_BUFFER) {
        alignWorkerToCenter(worker, target);
        return true;
      }
      if (distance === 0) {
        return true;
      }
      const step = speed * dt;
      const ratio = Math.min(1, step / distance);
      const moveX = dx * ratio;
      const moveY = dy * ratio;
      const movedX = moveWorker(worker, moveX, 0);
      const movedY = moveWorker(worker, 0, moveY);
      if ((!movedX && Math.abs(moveX) > 0.01) || (!movedY && Math.abs(moveY) > 0.01)) {
        worker.pathNeedsRecalc = true;
      }
      const newCenter = workerCenter(worker);
      return Math.hypot(target.x - newCenter.x, target.y - newCenter.y) <= WORKER_APPROACH_BUFFER;
    }

    function ensureWorkerPath(worker, target) {
      if (!target) {
        worker.path = null;
        worker.pathIndex = 0;
        worker.pathGoal = null;
        worker.pathBlocked = false;
        worker.pathFailureCooldown = 0;
        return false;
      }

      const goalCell = pointToCell(target);
      const goalKey = cellKey(goalCell);
      const currentCell = pointToCell(workerCenter(worker));

      if (cellsEqual(currentCell, goalCell)) {
        worker.path = null;
        worker.pathIndex = 0;
        worker.pathGoal = goalKey;
        worker.pathNeedsRecalc = false;
        worker.pathBlocked = false;
        worker.pathFailureCooldown = 0;
        return true;
      }

      const hasPathArray = Array.isArray(worker.path);
      const hasActivePath = hasPathArray && worker.pathIndex < worker.path.length;
      const needsNewPath =
        worker.pathNeedsRecalc ||
        worker.pathGoal !== goalKey ||
        (!hasActivePath && !hasPathArray);

      if (needsNewPath) {
        if (
          worker.pathBlocked &&
          worker.pathFailureCooldown > 0 &&
          !worker.pathNeedsRecalc &&
          worker.pathGoal === goalKey
        ) {
          return false;
        }

        const pathCells = findPath(currentCell, goalCell, worker);

        if (pathCells && pathCells.length > 0) {
          if (cellsEqual(pathCells[0], currentCell)) {
            pathCells.shift();
          }
          worker.path = pathCells.map(cellToCenter);
          worker.pathIndex = 0;
          worker.pathBlocked = false;
          worker.pathFailureCooldown = 0;
        } else {
          worker.path = null;
          worker.pathIndex = 0;
          worker.pathBlocked = true;
          worker.pathFailureCooldown = PATH_FAILURE_RETRY;
          worker.pathGoal = goalKey;
          worker.pathNeedsRecalc = false;
          worker.pathReplanTimer = 0;
          return false;
        }

        worker.pathGoal = goalKey;
        worker.pathNeedsRecalc = false;
        worker.pathReplanTimer = 0;
        return true;
      }

      return true;
    }

    function setWorkerDestination(worker, target) {
      if (!target) {
        worker.target = null;
        worker.path = null;
        worker.pathIndex = 0;
        worker.pathGoal = null;
        worker.pathNeedsRecalc = false;
        worker.pathReplanTimer = 0;
        worker.pathBlocked = false;
        worker.pathFailureCooldown = 0;
        return;
      }
      worker.target = target;
      worker.pathNeedsRecalc = true;
      worker.pathGoal = null;
      worker.pathReplanTimer = 0;
      worker.pathBlocked = false;
      worker.pathFailureCooldown = 0;
    }

    function moveWorkerToward(worker, target, speed, dt) {
      if (!target) {
        return false;
      }

      const pathReady = ensureWorkerPath(worker, target);
      if (!pathReady) {
        return false;
      }

      if (worker.path && worker.pathIndex < worker.path.length) {
        const waypoint = worker.path[worker.pathIndex];
        if (moveTowardPoint(worker, waypoint, speed, dt)) {
          worker.pathIndex += 1;
        }
        if (worker.pathIndex < worker.path.length) {
          return false;
        }
      }

      const arrived = moveTowardPoint(worker, target, speed, dt);
      if (arrived) {
        worker.path = null;
        worker.pathIndex = 0;
        worker.pathGoal = null;
        worker.pathNeedsRecalc = false;
        worker.pathReplanTimer = 0;
        worker.pathBlocked = false;
        worker.pathFailureCooldown = 0;
        return true;
      }

      return false;
    }

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
      ctx.lineWidth = 1;
      for (let col = 1; col < grid.cols; col++) {
        const x = col * grid.cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let row = 1; row < grid.rows; row++) {
        const y = row * grid.cell + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function drawRocks() {
      rocks.forEach(rock => {
        const pattern = rock.kind === 'pond'
          ? textures.pond
          : rock.kind === 'fountain'
            ? textures.pond
            : textures.rock;
        rock.cells.forEach(cell => {
          const x = cell.col * grid.cell;
          const y = cell.row * grid.cell;
          ctx.fillStyle = pattern;
          ctx.fillRect(x, y, grid.cell, grid.cell);
          ctx.strokeStyle = rock.kind === 'pond' ? '#0b2038' : '#11141d';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 1, y + 1, grid.cell - 2, grid.cell - 2);
          if (rock.kind === 'pond' || rock.kind === 'fountain') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.18)';
            ctx.fillRect(x + 4, y + 4, grid.cell - 8, 3);
          } else {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.fillRect(x, y + grid.cell - 6, grid.cell, 6);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.fillRect(x + 6, y + 6, 6, 2);
          }
        });
      });
    }

    function drawZones() {
      zones.forEach(zone => {
        ctx.fillStyle = zone.color instanceof CanvasPattern ? zone.color : zone.color;
        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);

        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.fillRect(zone.x, zone.y, zone.width, 4);

        ctx.strokeStyle = '#0a0d18';
        ctx.lineWidth = 2;
        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
        ctx.strokeStyle = 'rgba(252, 227, 138, 0.45)';
        ctx.lineWidth = 1;
        ctx.strokeRect(zone.x - 3, zone.y - 3, zone.width + 6, zone.height + 6);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
        ctx.fillRect(zone.x, zone.y, zone.width, 18);

        ctx.fillStyle = '#f7f7fb';
        ctx.font = '12px "Press Start 2P", "VT323", monospace';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'center';
        ctx.fillText(zone.name, zone.x + zone.width / 2, zone.y + 2);

        ctx.font = '10px "Press Start 2P", "VT323", monospace';
        ctx.fillStyle = 'rgba(252, 227, 138, 0.85)';
        ctx.fillText('SPACE', zone.x + zone.width / 2, zone.y + zone.height - 18);
      });
      ctx.textAlign = 'left';
    }

    function drawWorkers() {
      ctx.font = '10px "Press Start 2P", "VT323", monospace';
      ctx.textBaseline = 'bottom';
      workers.forEach(worker => {
        if (!worker.visible) {
          return;
        }
        const bodyY = worker.y - worker.jumpOffset;
        ctx.fillStyle = '#00000088';
        ctx.fillRect(worker.x - 4, bodyY + worker.height, worker.width + 8, 6);

        const isIdle = worker.order === 'idle';
        ctx.fillStyle = isIdle ? worker.colorIdle : worker.colorActive;
        ctx.fillRect(worker.x, bodyY, worker.width, worker.height);

        ctx.fillStyle = isIdle ? '#5b6170' : worker.accentColor;
        ctx.fillRect(worker.x + 2, bodyY, worker.width - 4, 5);

        ctx.fillStyle = isIdle ? '#3f4554' : '#41434f';
        ctx.fillRect(worker.x + 4, bodyY + 4, 4, 4);
        ctx.fillRect(worker.x + worker.width - 8, bodyY + 4, 4, 4);

        ctx.fillStyle = isIdle ? '#6e7280' : '#f08080';
        ctx.fillRect(worker.x + 6, bodyY + worker.height - 6, worker.width - 12, 4);

        ctx.fillStyle = '#1d2238ee';
        ctx.fillRect(worker.x - 18, bodyY - 34, worker.width + 36, 30);

        ctx.fillStyle = '#f7f7fb';
        ctx.textAlign = 'center';
        ctx.fillText(worker.name, worker.x + worker.width / 2, bodyY - 12);
        ctx.fillStyle = isIdle ? '#9aa0b7' : '#fce38a';
        const staminaText = `${worker.stamina.toFixed(1)}/${MAX_STAMINA}`;
        const stateLabel = formatStateLabel(worker.stateMachine.state);
        ctx.fillText(`${stateLabel} · ${staminaText}`, worker.x + worker.width / 2, bodyY - 26);
      });
      ctx.textAlign = 'left';
    }

    function drawPlayer() {
      ctx.fillStyle = '#00000088';
      ctx.fillRect(player.x - 4, player.y + player.height, player.width + 8, 6);

      ctx.fillStyle = '#1d1f2f';
      ctx.fillRect(player.x + 4, player.y + 4, player.width - 8, player.height - 8);

      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height - 6);

      ctx.fillStyle = '#2b2e4a';
      ctx.fillRect(player.x + 6, player.y + 4, 4, 4);
      ctx.fillRect(player.x + player.width - 10, player.y + 4, 4, 4);

      ctx.fillStyle = '#f08080';
      ctx.fillRect(player.x + 6, player.y + player.height - 14, player.width - 12, 8);

      ctx.fillStyle = '#41436a';
      ctx.fillRect(player.x + 2, player.y + player.height - 6, player.width - 4, 6);

      if (player.item === 'coffee') {
        ctx.fillStyle = '#1d2238ee';
        ctx.fillRect(player.x - 14, player.y - 36, player.width + 28, 26);
        ctx.fillStyle = '#fce38a';
        ctx.font = '12px "Press Start 2P", "VT323", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('LATTE', player.x + player.width / 2, player.y - 23);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
      }
    }

    function drawScene() {
      if (textures.grass) {
        ctx.fillStyle = textures.grass;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#0e1320';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      drawGrid();
      drawRocks();
      drawZones();
      drawWorkers();
      drawPlayer();
    }

    function update(dt) {
      if (!isPaused) {
        handleMovement(dt);
        const scaledDt = dt * state.time.speed;
        state.time.elapsed += scaledDt;
        if (player.cooldown > 0) {
          player.cooldown = Math.max(0, player.cooldown - scaledDt);
        }
        updateWorkers(dt);
      }
      updateHUD();
    }

    function getContextZone() {
      const playerRect = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };
      return zones.find(zone => rectsOverlap(playerRect, expandedRect(zone, 10)));
    }

    function showBubble(message) {
      bubble.textContent = message;
      bubble.style.display = 'block';
      positionBubble();
      if (bubbleTimeout) {
        clearTimeout(bubbleTimeout);
      }
      bubbleTimeout = setTimeout(() => {
        bubble.style.display = 'none';
      }, 2200);
    }

    function interact() {
      if (player.cooldown > 0) {
        return;
      }
      player.cooldown = PLAYER_INTERACT_COOLDOWN;

      const zone = getContextZone();
      const nearbyWorker = findNearbyWorker();

      if (player.item === 'coffee' && nearbyWorker) {
        deliverCoffee();
        return;
      }

      if (zone && zone.name === 'Starbucks') {
        if (player.item === 'coffee') {
          showBubble('Arms full! Deliver this coffee first.');
        } else {
          player.item = 'coffee';
          showBubble('Hot coffee acquired! Find a worker to perk up.');
          statusEl.textContent = 'Coffee ready. Deliver to the crew to refill stamina.';
        }
        return;
      }

      if (nearbyWorker) {
        const stamina = nearbyWorker.stamina.toFixed(1);
        showBubble(`${nearbyWorker.name}: ${stamina}/${MAX_STAMINA} stamina.`);
        return;
      }

      if (zone) {
        showBubble(`${zone.name}: ${zone.description}`);
        return;
      }

      if (player.item === 'coffee') {
        showBubble('You carry coffee. Find a worker to share it.');
      } else {
        showBubble('You wave into the quiet night. Nothing happens.');
      }
    }

    function findNearbyWorker() {
      const px = player.x + player.width / 2;
      const py = player.y + player.height / 2;
      return workers.find(worker => {
        if (!worker.visible) {
          return false;
        }
        const wx = worker.x + worker.width / 2;
        const wy = worker.y + worker.height / 2 - worker.jumpOffset;
        return Math.hypot(px - wx, py - wy) <= grid.cell * 1.1;
      }) || null;
    }

    function deliverCoffee() {
      player.item = 'none';
      state.workers.forEach(worker => {
        worker.stamina = MAX_STAMINA;
        if (worker.order === 'rest') {
          worker.visible = true;
          if (worker.restAnchor) {
            alignWorkerToCenter(worker, worker.restAnchor);
          }
          setWorkerOrder(worker, 'idle', `${worker.name} perks up from the latte!`);
        }
      });
      const message = 'Workers refreshed by coffee!';
      statusEl.textContent = message;
      showBubble(message);
      refreshWorkerCards();
    }

    function togglePause() {
      isPaused = !isPaused;
      document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
      statusEl.textContent = isPaused ? 'Simulation paused.' : 'Simulation running.';
    }

    function cycleSpeed() {
      speedIndex = (speedIndex + 1) % speedOptions.length;
      state.time.speed = speedOptions[speedIndex];
      const label = Number.isInteger(state.time.speed) ? state.time.speed : state.time.speed.toFixed(1);
      document.getElementById('speedBtn').textContent = `Speed: ${label}×`;
      statusEl.textContent = `Speed set to ${label}×.`;
    }

    function toggleContrast() {
      document.body.classList.toggle('high-contrast');
      statusEl.textContent = document.body.classList.contains('high-contrast')
        ? 'High contrast enabled.'
        : 'High contrast disabled.';
    }

    function handleWorkerAction(workerKey, action) {
      const worker = workers.find(w => w.role === workerKey);
      if (!worker) {
        return;
      }
      if (worker.order === 'rest' && action !== 'cancel') {
        showBubble(`${worker.name} is resting at the dorm.`);
        return;
      }
      if (action === 'cancel') {
        setWorkerOrder(worker, 'idle');
        return;
      }
      if (action === 'rest') {
        setWorkerOrder(worker, 'rest');
        return;
      }
      if (workerKey === 'builder' && action === 'build') {
        setWorkerOrder(worker, 'build');
        return;
      }
      if (workerKey === 'delivery' && action === 'fetch') {
        setWorkerOrder(worker, 'deliver');
        return;
      }
    }

    function refreshWorkerCards() {
      workerCards.forEach(card => {
        const workerKey = card.dataset.worker;
        const worker = workers.find(w => w.role === workerKey);
        if (!worker) {
          return;
        }
        const orderLabel = card.querySelector('.order-label');
        if (orderLabel) {
          orderLabel.textContent = formatOrderLabel(worker.order, workerKey);
        }
        const staminaEl = card.querySelector('.summary .stamina');
        if (staminaEl) {
          staminaEl.textContent = worker.stamina.toFixed(1);
        }
        const stateEl = card.querySelector('.summary .state');
        if (stateEl) {
          stateEl.textContent = worker.stateMachine.state;
        }
        const buttons = card.querySelectorAll('button[data-action]');
        buttons.forEach(btn => {
          btn.classList.toggle('active', isActionActive(worker, btn.dataset.action));
        });
      });
    }



    function formatOrderLabel(order, workerKey) {
      if (order === 'build') {
        return 'Build';
      }
      if (order === 'deliver') {
        return workerKey === 'delivery' ? 'Fetch' : 'Deliver';
      }
      if (order === 'rest') {
        return 'Rest';
      }
      return 'Idle';
    }



    function formatStateLabel(state) {
      if (!state) {
        return 'Idle';
      }
      return state
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/^./, char => char.toUpperCase());
    }
    function isActionActive(worker, action) {
      if (action === 'build') {
        return worker.order === 'build';
      }
      if (action === 'fetch') {
        return worker.order === 'deliver';
      }
      if (action === 'rest') {
        return worker.order === 'rest';
      }
      if (action === 'cancel') {
        return worker.order === 'idle';
      }
      return false;
    }
    function setWorkerOrder(worker, newOrder, messageOverride) {
      if (worker.order === newOrder && !messageOverride) {
        return;
      }

      if (newOrder === 'build') {
        if (state.stock.wood < state.floor.need) {
          const msg = 'Need more wood before building.';
          statusEl.textContent = msg;
          showBubble(msg);
          refreshWorkerCards();
          return;
        }
        if (worker.stamina < STAMINA_BUILD_COST) {
          const msg = `${worker.name} is too tired to build and heads to the dorm.`;
          setWorkerOrder(worker, 'rest', msg);
          return;
        }
      } else if (newOrder === 'deliver') {
        if (worker.stamina < STAMINA_TRIP_COST) {
          const msg = `${worker.name} needs rest before delivering and walks to the dorm.`;
          setWorkerOrder(worker, 'rest', msg);
          return;
        }
      } else if (newOrder === 'rest') {
        if (worker.activity === 'resting') {
          refreshWorkerCards();
          return;
        }
      }

      const previousOrder = worker.order;
      worker.order = newOrder;

      if (previousOrder !== newOrder) {
        if (newOrder === 'build') {
          worker.stateMachine.transition('build', worker);
        } else if (newOrder === 'deliver') {
          worker.stateMachine.transition('fetch', worker);
        } else if (newOrder === 'rest') {
          worker.stateMachine.transition('rest', worker);
        } else if (newOrder === 'idle' && previousOrder !== 'rest') {
          worker.stateMachine.transition('cancel', worker);
        }
      }

      if (newOrder === 'idle') {
        worker.orderStarted = false;
        setWorkerDestination(worker, null);
        worker.tripTimer = 0;
        worker.idleCooldown = Math.random() * 0.6;
        worker.hasJumped = false;
        worker.activity = 'idle';
        worker.buildReserved = false;
        worker.inv = 0;
        worker.visible = true;
      } else {
        setWorkerDestination(worker, null);
        if (newOrder === 'build') {
          worker.orderStarted = false;
          worker.buildReserved = false;
          worker.activity = 'toSite';
          setWorkerDestination(worker, getApproachCenter('MCS Construction'));
        }
        if (newOrder === 'deliver') {
          worker.tripTimer = 0;
          worker.inv = 0;
          worker.activity = 'toWood';
          setWorkerDestination(worker, getApproachCenter('Wood House'));
        }
        if (newOrder === 'rest') {
          worker.activity = 'toDorm';
          setWorkerDestination(worker, getApproachCenter('Dorm Beds'));
          worker.restAnchor = null;
          worker.visible = true;
          worker.inv = 0;
        }
      }

      let message = messageOverride;
      if (!message) {
        if (newOrder === 'idle') {
          message = `${worker.name} is idling and waiting for orders.`;
        } else if (newOrder === 'build') {
          message = `${worker.name} starts building floor ${state.floor.n}.`;
        } else if (newOrder === 'deliver') {
          message = `${worker.name} begins fetching wood.`;
        } else if (newOrder === 'rest') {
          message = `${worker.name} walks to the dorm for a break.`;
        }
      }

      if (message) {
        statusEl.textContent = message;
        showBubble(message);
      }
      refreshWorkerCards();
    }


    function positionBubble() {
      if (bubble.style.display === 'none') {
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const pageX = rect.left + window.scrollX + player.x + player.width / 2;
      const pageY = rect.top + window.scrollY + player.y - 10;
      bubble.style.left = `${pageX}px`;
      bubble.style.top = `${pageY}px`;
    }

    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault();
        interact();
        return;
      }
      keys[event.code] = true;
    });

    document.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });

    window.addEventListener('resize', positionBubble);
    window.addEventListener('scroll', positionBubble);

    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('speedBtn').addEventListener('click', cycleSpeed);
    document.getElementById('contrastBtn').addEventListener('click', toggleContrast);

    workerCards.forEach(card => {
      const workerKey = card.dataset.worker;
      const buttons = card.querySelectorAll('button[data-action]');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          handleWorkerAction(workerKey, btn.dataset.action);
        });
      });
    });

    updateHUD();
    refreshWorkerCards();
    drawScene();
    setInterval(() => {
      update(1 / FPS);
      drawScene();
      positionBubble();
    }, frameDuration);
  </script>
</body>
</html>
